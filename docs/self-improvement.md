# Self-Improvement è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## æ¦‚è¦

dursor ã‚’ **äººé–“ã®ä»‹å…¥ãªã—ã«AIãŒè‡ªã‚‰ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚’æ”¹å–„ã§ãã‚‹** ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦è¨­è¨ˆã™ã‚‹ã€‚

æœ¬æ©Ÿèƒ½ã«ã‚ˆã‚Šã€dursorã¯ï¼š
1. è‡ªèº«ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’åˆ†æã—ã€æ”¹å–„ç‚¹ã‚’ç™ºè¦‹
2. æ”¹å–„ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•ç”Ÿæˆ
3. Full Autoãƒ¢ãƒ¼ãƒ‰ã§æ”¹å–„ã‚’å®Ÿè£…
4. ç¶™ç¶šçš„ãªæ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’è‡ªå¾‹çš„ã«å®Ÿè¡Œ

### ãƒ“ã‚¸ãƒ§ãƒ³

```mermaid
graph TB
    subgraph "Self-Improvement Cycle"
        A[ğŸ” Analyze<br/>ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹åˆ†æ] --> B[ğŸ“‹ Plan<br/>æ”¹å–„ã‚¿ã‚¹ã‚¯ç”Ÿæˆ]
        B --> C[ğŸ¤– Execute<br/>Full Autoå®Ÿè£…]
        C --> D[âœ… Verify<br/>å“è³ªæ¤œè¨¼]
        D --> E[ğŸ“Š Learn<br/>çµæœå­¦ç¿’]
        E --> A
    end
    
    H[Human] -.->|åˆæœŸè¨­å®š<br/>ãƒãƒªã‚·ãƒ¼å®šç¾©| A
    D -.->|é€šçŸ¥ãƒ»æ‰¿èªè¦æ±‚| H
```

### è¨­è¨ˆåŸå‰‡

| # | åŸå‰‡ | èª¬æ˜ |
|---|------|------|
| 1 | **Safety First** | ç ´å£Šçš„å¤‰æ›´ã¯è‡ªå‹•é©ç”¨ã—ãªã„ã€æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤ |
| 2 | **Observable** | ã™ã¹ã¦ã®æ”¹å–„æ´»å‹•ã‚’è¿½è·¡ãƒ»å¯è¦–åŒ–å¯èƒ½ |
| 3 | **Controllable** | äººé–“ãŒã„ã¤ã§ã‚‚ä»‹å…¥ãƒ»åœæ­¢å¯èƒ½ |
| 4 | **Incremental** | å°ã•ãªæ”¹å–„ã‚’ç©ã¿é‡ã­ã‚‹ï¼ˆBig Bangç¦æ­¢ï¼‰|
| 5 | **Reversible** | ã™ã¹ã¦ã®å¤‰æ›´ã¯ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½ |

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [Agentic Dursor](./agentic-dursor.md) - Full Autoãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…è©³ç´°
- [Coding Mode](./coding-mode.md) - 3ã¤ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã®å®šç¾©
- [Code Review](./review.md) - AIãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
- [Kanban](./kanban.md) - ã‚¿ã‚¹ã‚¯ç®¡ç†

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“åƒ

```mermaid
flowchart TB
    subgraph SelfImprovement["Self-Improvement System"]
        subgraph Analyzer["Analysis Layer"]
            CA[Code Analyzer<br/>ã‚³ãƒ¼ãƒ‰å“è³ªåˆ†æ]
            TA[Test Analyzer<br/>ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æ]
            DA[Dependency Analyzer<br/>ä¾å­˜é–¢ä¿‚åˆ†æ]
            PA[Performance Analyzer<br/>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ]
            SA[Security Analyzer<br/>ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ†æ]
            IA[Issue Analyzer<br/>GitHub Issueåˆ†æ]
        end
        
        subgraph Planner["Planning Layer"]
            IP[Improvement Planner<br/>æ”¹å–„è¨ˆç”»ç”Ÿæˆ]
            TP[Task Prioritizer<br/>å„ªå…ˆåº¦æ±ºå®š]
            RP[Risk Assessor<br/>ãƒªã‚¹ã‚¯è©•ä¾¡]
        end
        
        subgraph Executor["Execution Layer"]
            AO[Agentic Orchestrator<br/>Full Autoå®Ÿè¡Œ]
            VM[Verification Module<br/>å“è³ªæ¤œè¨¼]
        end
        
        subgraph Learner["Learning Layer"]
            RL[Result Logger<br/>çµæœè¨˜éŒ²]
            ML[Metrics Learner<br/>æ”¹å–„åŠ¹æœå­¦ç¿’]
        end
    end
    
    subgraph External["External Systems"]
        GH[GitHub<br/>Issues/PRs]
        CI[CI/CD<br/>ãƒ†ã‚¹ãƒˆãƒ»ãƒ“ãƒ«ãƒ‰]
        DB[(Database<br/>å±¥æ­´ãƒ»è¨­å®š)]
    end
    
    CA & TA & DA & PA & SA & IA --> IP
    IP --> TP
    TP --> RP
    RP --> AO
    AO --> VM
    VM --> RL
    RL --> ML
    ML -.->|ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯| IP
    
    GH --> IA
    AO --> GH
    AO --> CI
    RL --> DB
```

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°

#### 1. Analysis Layerï¼ˆåˆ†æå±¤ï¼‰

| Analyzer | å½¹å‰² | å…¥åŠ› | å‡ºåŠ› |
|----------|------|------|------|
| **Code Analyzer** | ã‚³ãƒ¼ãƒ‰å“è³ªãƒ»æŠ€è¡“çš„è² å‚µã®æ¤œå‡º | ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ | QualityIssue[] |
| **Test Analyzer** | ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ»æ¬ è½ãƒ†ã‚¹ãƒˆã®æ¤œå‡º | ãƒ†ã‚¹ãƒˆçµæœã€ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ | TestGap[] |
| **Dependency Analyzer** | ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ›´æ–°ãƒ»è„†å¼±æ€§æ¤œå‡º | package.json, pyproject.toml | DependencyUpdate[] |
| **Performance Analyzer** | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒœãƒˆãƒ«ãƒãƒƒã‚¯æ¤œå‡º | ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã€ãƒ¡ãƒˆãƒªã‚¯ã‚¹ | PerformanceIssue[] |
| **Security Analyzer** | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§æ¤œå‡º | ã‚³ãƒ¼ãƒ‰ã€ä¾å­˜é–¢ä¿‚ | SecurityVulnerability[] |
| **Issue Analyzer** | GitHub Issueã‹ã‚‰æ”¹å–„è¦æ±‚ã‚’æŠ½å‡º | GitHub Issues | FeatureRequest[] |

#### 2. Planning Layerï¼ˆè¨ˆç”»å±¤ï¼‰

| Component | å½¹å‰² | è©³ç´° |
|-----------|------|------|
| **Improvement Planner** | æ”¹å–„ã‚¿ã‚¹ã‚¯ã®ç”Ÿæˆ | åˆ†æçµæœã‹ã‚‰å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ |
| **Task Prioritizer** | å„ªå…ˆåº¦æ±ºå®š | ROIã€ãƒªã‚¹ã‚¯ã€å½±éŸ¿åº¦ã‹ã‚‰å„ªå…ˆåº¦ã‚’è¨ˆç®— |
| **Risk Assessor** | ãƒªã‚¹ã‚¯è©•ä¾¡ | å¤‰æ›´ã®ç ´å£Šçš„å½±éŸ¿åº¦ã‚’è©•ä¾¡ |

#### 3. Execution Layerï¼ˆå®Ÿè¡Œå±¤ï¼‰

| Component | å½¹å‰² | è©³ç´° |
|-----------|------|------|
| **Agentic Orchestrator** | Full Autoå®Ÿè¡Œ | æ—¢å­˜ã®AgenticOrchestratorã‚’æ´»ç”¨ |
| **Verification Module** | å“è³ªæ¤œè¨¼ | CIé€šéã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¹ã‚³ã‚¢ã€å›å¸°ãƒ†ã‚¹ãƒˆ |

#### 4. Learning Layerï¼ˆå­¦ç¿’å±¤ï¼‰

| Component | å½¹å‰² | è©³ç´° |
|-----------|------|------|
| **Result Logger** | çµæœè¨˜éŒ² | æ”¹å–„ã®æˆåŠŸ/å¤±æ•—ã€ãƒ¡ãƒˆãƒªã‚¯ã‚¹å¤‰åŒ– |
| **Metrics Learner** | åŠ¹æœå­¦ç¿’ | æ”¹å–„åŠ¹æœã‚’åˆ†æã—ã€æ¬¡ã®è¨ˆç”»ã«åæ˜  |

---

## ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### æ”¹å–„ã‚«ãƒ†ã‚´ãƒª

```python
# apps/api/src/dursor_api/domain/enums.py

class ImprovementCategory(str, Enum):
    """è‡ªå·±æ”¹å–„ã®ã‚«ãƒ†ã‚´ãƒª"""
    CODE_QUALITY = "code_quality"           # ã‚³ãƒ¼ãƒ‰å“è³ªå‘ä¸Š
    TEST_COVERAGE = "test_coverage"         # ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸å‘ä¸Š
    DEPENDENCY_UPDATE = "dependency_update" # ä¾å­˜é–¢ä¿‚æ›´æ–°
    PERFORMANCE = "performance"             # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„
    SECURITY = "security"                   # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿®æ­£
    DOCUMENTATION = "documentation"         # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ”¹å–„
    REFACTORING = "refactoring"             # ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
    BUG_FIX = "bug_fix"                     # ãƒã‚°ä¿®æ­£
    FEATURE = "feature"                     # æ©Ÿèƒ½è¿½åŠ 


class ImprovementPriority(str, Enum):
    """æ”¹å–„ã®å„ªå…ˆåº¦"""
    CRITICAL = "critical"   # å³æ™‚å¯¾å¿œå¿…é ˆï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ç­‰ï¼‰
    HIGH = "high"           # é«˜å„ªå…ˆåº¦
    MEDIUM = "medium"       # ä¸­å„ªå…ˆåº¦
    LOW = "low"             # ä½å„ªå…ˆåº¦
    BACKLOG = "backlog"     # ã„ã¤ã‹å¯¾å¿œ


class ImprovementRisk(str, Enum):
    """å¤‰æ›´ã®ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«"""
    NONE = "none"           # ãƒªã‚¹ã‚¯ãªã—ï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã¿ç­‰ï¼‰
    LOW = "low"             # ä½ãƒªã‚¹ã‚¯ï¼ˆãƒ†ã‚¹ãƒˆè¿½åŠ ç­‰ï¼‰
    MEDIUM = "medium"       # ä¸­ãƒªã‚¹ã‚¯ï¼ˆãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ç­‰ï¼‰
    HIGH = "high"           # é«˜ãƒªã‚¹ã‚¯ï¼ˆAPIå¤‰æ›´ç­‰ï¼‰
    BREAKING = "breaking"   # ç ´å£Šçš„å¤‰æ›´ï¼ˆäººé–“æ‰¿èªå¿…é ˆï¼‰


class ImprovementStatus(str, Enum):
    """æ”¹å–„ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""
    PROPOSED = "proposed"           # AIææ¡ˆä¸­
    APPROVED = "approved"           # æ‰¿èªæ¸ˆã¿ï¼ˆè‡ªå‹•ã¾ãŸã¯äººé–“ï¼‰
    SCHEDULED = "scheduled"         # å®Ÿè¡Œäºˆå®š
    IN_PROGRESS = "in_progress"     # å®Ÿè¡Œä¸­
    VERIFYING = "verifying"         # æ¤œè¨¼ä¸­
    COMPLETED = "completed"         # å®Œäº†
    FAILED = "failed"               # å¤±æ•—
    REJECTED = "rejected"           # å´ä¸‹
    DEFERRED = "deferred"           # å»¶æœŸ
```

### æ”¹å–„ææ¡ˆãƒ¢ãƒ‡ãƒ«

```python
# apps/api/src/dursor_api/domain/models.py

class ImprovementProposal(BaseModel):
    """AIãŒç”Ÿæˆã—ãŸæ”¹å–„ææ¡ˆ"""
    
    id: str
    repo_id: str
    category: ImprovementCategory
    priority: ImprovementPriority
    risk: ImprovementRisk
    status: ImprovementStatus
    
    # ææ¡ˆå†…å®¹
    title: str
    description: str
    rationale: str = Field(..., description="æ”¹å–„ã®æ ¹æ‹ ãƒ»ç†ç”±")
    expected_benefit: str = Field(..., description="æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ")
    
    # å¯¾è±¡
    target_files: list[str] = Field(default_factory=list)
    affected_areas: list[str] = Field(default_factory=list)
    
    # ãƒ¡ãƒˆãƒªã‚¯ã‚¹
    estimated_effort: str | None = Field(None, description="æ¨å®šå·¥æ•°")
    impact_score: float = Field(..., ge=0.0, le=1.0, description="å½±éŸ¿åº¦ã‚¹ã‚³ã‚¢")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="AIç¢ºä¿¡åº¦")
    
    # åˆ†æã‚½ãƒ¼ã‚¹
    source_analyzer: str = Field(..., description="æ¤œå‡ºã—ãŸåˆ†æå™¨")
    source_data: dict | None = Field(None, description="åˆ†æã®å…ƒãƒ‡ãƒ¼ã‚¿")
    
    # é–¢é€£
    related_issues: list[str] = Field(default_factory=list, description="é–¢é€£GitHub Issue")
    blocking_proposals: list[str] = Field(default_factory=list, description="ä¾å­˜ã™ã‚‹ä»–ã®ææ¡ˆ")
    
    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    created_at: datetime
    updated_at: datetime
    approved_at: datetime | None = None
    completed_at: datetime | None = None
    
    # å®Ÿè¡Œçµæœ
    task_id: str | None = Field(None, description="å®Ÿè¡Œæ™‚ã®Task ID")
    pr_number: int | None = Field(None, description="ä½œæˆã•ã‚ŒãŸPRç•ªå·")
    result_summary: str | None = None


class ImprovementCycle(BaseModel):
    """æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã®å®Ÿè¡Œè¨˜éŒ²"""
    
    id: str
    repo_id: str
    started_at: datetime
    completed_at: datetime | None = None
    status: str  # "running", "completed", "failed"
    
    # åˆ†æçµæœ
    analysis_summary: dict = Field(default_factory=dict)
    proposals_generated: int = 0
    proposals_approved: int = 0
    proposals_executed: int = 0
    proposals_completed: int = 0
    
    # åŠ¹æœæ¸¬å®š
    metrics_before: dict | None = None
    metrics_after: dict | None = None
    improvement_delta: dict | None = None


class ImprovementPolicy(BaseModel):
    """æ”¹å–„ãƒãƒªã‚·ãƒ¼ï¼ˆäººé–“ãŒè¨­å®šï¼‰"""
    
    id: str
    repo_id: str
    
    # æœ‰åŠ¹/ç„¡åŠ¹è¨­å®š
    enabled: bool = True
    enabled_categories: list[ImprovementCategory] = Field(
        default_factory=lambda: list(ImprovementCategory)
    )
    
    # è‡ªå‹•å®Ÿè¡Œè¨­å®š
    auto_approve_risk_levels: list[ImprovementRisk] = Field(
        default_factory=lambda: [ImprovementRisk.NONE, ImprovementRisk.LOW]
    )
    require_human_approval_for: list[ImprovementRisk] = Field(
        default_factory=lambda: [ImprovementRisk.HIGH, ImprovementRisk.BREAKING]
    )
    
    # åˆ¶é™
    max_concurrent_improvements: int = 3
    max_improvements_per_day: int = 10
    max_risk_score_auto: float = 0.5
    
    # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    schedule_cron: str | None = Field(
        "0 2 * * 1",  # æ¯é€±æœˆæ›œ2:00
        description="æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã®cronå¼"
    )
    
    # é€šçŸ¥
    notify_on_proposal: bool = True
    notify_on_completion: bool = True
    notification_channels: list[str] = Field(default_factory=list)
    
    created_at: datetime
    updated_at: datetime
```

### DBã‚¹ã‚­ãƒ¼ãƒ

```sql
-- apps/api/src/dursor_api/storage/schema.sql

-- æ”¹å–„ææ¡ˆãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS improvement_proposals (
    id TEXT PRIMARY KEY,
    repo_id TEXT NOT NULL,
    category TEXT NOT NULL,
    priority TEXT NOT NULL,
    risk TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'proposed',
    
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    rationale TEXT NOT NULL,
    expected_benefit TEXT NOT NULL,
    
    target_files TEXT,  -- JSON array
    affected_areas TEXT,  -- JSON array
    
    estimated_effort TEXT,
    impact_score REAL NOT NULL,
    confidence_score REAL NOT NULL,
    
    source_analyzer TEXT NOT NULL,
    source_data TEXT,  -- JSON
    
    related_issues TEXT,  -- JSON array
    blocking_proposals TEXT,  -- JSON array
    
    task_id TEXT,
    pr_number INTEGER,
    result_summary TEXT,
    
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    approved_at DATETIME,
    completed_at DATETIME,
    
    FOREIGN KEY (repo_id) REFERENCES repos(id) ON DELETE CASCADE,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL
);

CREATE INDEX idx_proposals_repo ON improvement_proposals(repo_id);
CREATE INDEX idx_proposals_status ON improvement_proposals(status);
CREATE INDEX idx_proposals_priority ON improvement_proposals(priority);
CREATE INDEX idx_proposals_category ON improvement_proposals(category);


-- æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«è¨˜éŒ²ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS improvement_cycles (
    id TEXT PRIMARY KEY,
    repo_id TEXT NOT NULL,
    started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    status TEXT NOT NULL DEFAULT 'running',
    
    analysis_summary TEXT,  -- JSON
    proposals_generated INTEGER DEFAULT 0,
    proposals_approved INTEGER DEFAULT 0,
    proposals_executed INTEGER DEFAULT 0,
    proposals_completed INTEGER DEFAULT 0,
    
    metrics_before TEXT,  -- JSON
    metrics_after TEXT,  -- JSON
    improvement_delta TEXT,  -- JSON
    
    FOREIGN KEY (repo_id) REFERENCES repos(id) ON DELETE CASCADE
);

CREATE INDEX idx_cycles_repo ON improvement_cycles(repo_id);
CREATE INDEX idx_cycles_status ON improvement_cycles(status);


-- æ”¹å–„ãƒãƒªã‚·ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS improvement_policies (
    id TEXT PRIMARY KEY,
    repo_id TEXT NOT NULL UNIQUE,
    
    enabled INTEGER NOT NULL DEFAULT 1,
    enabled_categories TEXT,  -- JSON array
    
    auto_approve_risk_levels TEXT,  -- JSON array
    require_human_approval_for TEXT,  -- JSON array
    
    max_concurrent_improvements INTEGER DEFAULT 3,
    max_improvements_per_day INTEGER DEFAULT 10,
    max_risk_score_auto REAL DEFAULT 0.5,
    
    schedule_cron TEXT DEFAULT '0 2 * * 1',
    
    notify_on_proposal INTEGER DEFAULT 1,
    notify_on_completion INTEGER DEFAULT 1,
    notification_channels TEXT,  -- JSON array
    
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (repo_id) REFERENCES repos(id) ON DELETE CASCADE
);
```

---

## åˆ†æã‚·ã‚¹ãƒ†ãƒ 

### Code Analyzerï¼ˆã‚³ãƒ¼ãƒ‰å“è³ªåˆ†æï¼‰

```python
# apps/api/src/dursor_api/analyzers/code_analyzer.py

from dataclasses import dataclass
from abc import ABC, abstractmethod


@dataclass
class QualityIssue:
    """ã‚³ãƒ¼ãƒ‰å“è³ªã®å•é¡Œ"""
    file_path: str
    line_start: int | None
    line_end: int | None
    severity: str  # "critical", "high", "medium", "low"
    category: str  # "complexity", "duplication", "style", "smell"
    title: str
    description: str
    suggestion: str | None


class CodeAnalyzer:
    """ã‚³ãƒ¼ãƒ‰å“è³ªã‚’åˆ†æã—ã¦æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆ"""
    
    def __init__(
        self,
        llm_client: LLMClient,
        ruff_enabled: bool = True,
        mypy_enabled: bool = True,
    ):
        self.llm_client = llm_client
        self.ruff_enabled = ruff_enabled
        self.mypy_enabled = mypy_enabled
    
    async def analyze(self, workspace_path: str) -> list[QualityIssue]:
        """ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’åˆ†æã—ã¦å“è³ªå•é¡Œã‚’æ¤œå‡º"""
        issues: list[QualityIssue] = []
        
        # 1. é™çš„è§£æãƒ„ãƒ¼ãƒ«ã®çµæœã‚’åé›†
        if self.ruff_enabled:
            issues.extend(await self._run_ruff_analysis(workspace_path))
        
        if self.mypy_enabled:
            issues.extend(await self._run_mypy_analysis(workspace_path))
        
        # 2. LLMã«ã‚ˆã‚‹é«˜åº¦ãªåˆ†æ
        llm_issues = await self._run_llm_analysis(workspace_path)
        issues.extend(llm_issues)
        
        # 3. é‡è¤‡é™¤å»ã¨å„ªå…ˆåº¦ä»˜ã‘
        issues = self._deduplicate_and_prioritize(issues)
        
        return issues
    
    async def _run_llm_analysis(self, workspace_path: str) -> list[QualityIssue]:
        """LLMã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰å“è³ªåˆ†æ"""
        
        # ä¸»è¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†
        files = self._collect_source_files(workspace_path)
        
        prompt = """
        ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’åˆ†æã—ã€æ”¹å–„ã™ã¹ãç‚¹ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ã€‚
        
        åˆ†æè¦³ç‚¹:
        1. å¾ªç’°çš„è¤‡é›‘åº¦ãŒé«˜ã„é–¢æ•°
        2. ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡
        3. è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³é•å
        4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¸å‚™
        5. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œã®å¯èƒ½æ€§
        6. ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®å•é¡Œ
        
        å„å•é¡Œã«ã¤ã„ã¦ä»¥ä¸‹ã®å½¢å¼ã§JSONé…åˆ—ã¨ã—ã¦å‡ºåŠ›:
        {
            "file_path": "ç›¸å¯¾ãƒ‘ã‚¹",
            "line_start": é–‹å§‹è¡Œ,
            "line_end": çµ‚äº†è¡Œ,
            "severity": "critical|high|medium|low",
            "category": "complexity|duplication|design|error_handling|performance|testability",
            "title": "ç°¡æ½”ãªã‚¿ã‚¤ãƒˆãƒ«",
            "description": "è©³ç´°ãªèª¬æ˜",
            "suggestion": "æ”¹å–„æ¡ˆ"
        }
        """
        
        response = await self.llm_client.generate(
            messages=[{"role": "user", "content": prompt + "\n\n" + files}],
            system="You are a code quality expert.",
        )
        
        return self._parse_llm_response(response)
```

### Dependency Analyzerï¼ˆä¾å­˜é–¢ä¿‚åˆ†æï¼‰

```python
# apps/api/src/dursor_api/analyzers/dependency_analyzer.py

@dataclass
class DependencyUpdate:
    """ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ›´æ–°æƒ…å ±"""
    package_name: str
    current_version: str
    latest_version: str
    update_type: str  # "major", "minor", "patch", "security"
    changelog_url: str | None
    breaking_changes: list[str]
    vulnerabilities: list[dict] | None


class DependencyAnalyzer:
    """ä¾å­˜é–¢ä¿‚ã‚’åˆ†æã—ã¦æ›´æ–°ææ¡ˆã‚’ç”Ÿæˆ"""
    
    async def analyze(self, workspace_path: str) -> list[DependencyUpdate]:
        """ä¾å­˜é–¢ä¿‚ã‚’åˆ†æ"""
        updates: list[DependencyUpdate] = []
        
        # Python (pyproject.toml)
        pyproject_path = Path(workspace_path) / "pyproject.toml"
        if pyproject_path.exists():
            updates.extend(await self._analyze_python_deps(pyproject_path))
        
        # Node.js (package.json)
        package_json_path = Path(workspace_path) / "package.json"
        if package_json_path.exists():
            updates.extend(await self._analyze_node_deps(package_json_path))
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯
        updates = await self._check_vulnerabilities(updates)
        
        return updates
    
    async def _analyze_python_deps(self, pyproject_path: Path) -> list[DependencyUpdate]:
        """Pythonä¾å­˜é–¢ä¿‚ã‚’åˆ†æ"""
        # pip-audit, safetyç­‰ã‚’ä½¿ç”¨
        # PyPI APIã§æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—
        ...
    
    async def _check_vulnerabilities(
        self, updates: list[DependencyUpdate]
    ) -> list[DependencyUpdate]:
        """è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯"""
        # GitHub Advisory Database
        # OSV (Open Source Vulnerabilities)
        ...
```

### Issue Analyzerï¼ˆGitHub Issueåˆ†æï¼‰

```python
# apps/api/src/dursor_api/analyzers/issue_analyzer.py

@dataclass
class FeatureRequest:
    """GitHub Issueã‹ã‚‰æŠ½å‡ºã—ãŸæ©Ÿèƒ½è¦æ±‚"""
    issue_number: int
    title: str
    description: str
    labels: list[str]
    priority: str
    estimated_complexity: str
    implementation_hints: list[str]


class IssueAnalyzer:
    """GitHub Issueã‚’åˆ†æã—ã¦å®Ÿè£…å¯èƒ½ãªã‚¿ã‚¹ã‚¯ã‚’æŠ½å‡º"""
    
    def __init__(
        self,
        github_service: GitHubService,
        llm_client: LLMClient,
    ):
        self.github = github_service
        self.llm_client = llm_client
    
    async def analyze(self, repo_id: str) -> list[FeatureRequest]:
        """ã‚ªãƒ¼ãƒ—ãƒ³ãªIssueã‚’åˆ†æ"""
        
        # 1. ã‚ªãƒ¼ãƒ—ãƒ³ãªIssueã‚’å–å¾—
        issues = await self.github.list_issues(
            repo_id=repo_id,
            state="open",
            labels=["enhancement", "bug", "good first issue"],
        )
        
        # 2. LLMã§å®Ÿè£…å¯èƒ½æ€§ã‚’åˆ†æ
        analyzable_issues = []
        for issue in issues:
            analysis = await self._analyze_issue(issue)
            if analysis.is_implementable:
                analyzable_issues.append(analysis)
        
        return analyzable_issues
    
    async def _analyze_issue(self, issue: GitHubIssue) -> FeatureRequest:
        """å˜ä¸€Issueã‚’åˆ†æ"""
        
        prompt = f"""
        ä»¥ä¸‹ã®GitHub Issueã‚’åˆ†æã—ã€AIãŒè‡ªå‹•å®Ÿè£…å¯èƒ½ã‹è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚
        
        Issue #{issue.number}: {issue.title}
        {issue.body}
        
        Labels: {', '.join(issue.labels)}
        
        ä»¥ä¸‹ã®å½¢å¼ã§JSONå‡ºåŠ›:
        {{
            "is_implementable": true/false,
            "confidence": 0.0-1.0,
            "complexity": "trivial|simple|medium|complex|very_complex",
            "implementation_hints": ["ãƒ’ãƒ³ãƒˆ1", "ãƒ’ãƒ³ãƒˆ2"],
            "risks": ["ãƒªã‚¹ã‚¯1"],
            "dependencies": ["ä¾å­˜ã™ã‚‹Issueç•ªå·"]
        }}
        """
        
        response = await self.llm_client.generate(
            messages=[{"role": "user", "content": prompt}],
            system="You are a software architect analyzing GitHub issues.",
        )
        
        return self._parse_analysis(issue, response)
```

---

## è¨ˆç”»ã‚·ã‚¹ãƒ†ãƒ 

### Improvement Plannerï¼ˆæ”¹å–„è¨ˆç”»ç”Ÿæˆï¼‰

```python
# apps/api/src/dursor_api/services/improvement_planner.py

class ImprovementPlanner:
    """åˆ†æçµæœã‹ã‚‰æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆ"""
    
    def __init__(
        self,
        llm_client: LLMClient,
        proposal_dao: ImprovementProposalDAO,
    ):
        self.llm_client = llm_client
        self.proposal_dao = proposal_dao
    
    async def generate_proposals(
        self,
        repo_id: str,
        analysis_results: AnalysisResults,
    ) -> list[ImprovementProposal]:
        """åˆ†æçµæœã‹ã‚‰æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆ"""
        
        proposals: list[ImprovementProposal] = []
        
        # 1. ã‚³ãƒ¼ãƒ‰å“è³ªå•é¡Œã‹ã‚‰ææ¡ˆç”Ÿæˆ
        for issue in analysis_results.quality_issues:
            proposal = await self._create_quality_proposal(repo_id, issue)
            proposals.append(proposal)
        
        # 2. ä¾å­˜é–¢ä¿‚æ›´æ–°ã‹ã‚‰ææ¡ˆç”Ÿæˆ
        for update in analysis_results.dependency_updates:
            proposal = await self._create_dependency_proposal(repo_id, update)
            proposals.append(proposal)
        
        # 3. GitHub Issueã‹ã‚‰ææ¡ˆç”Ÿæˆ
        for feature in analysis_results.feature_requests:
            proposal = await self._create_feature_proposal(repo_id, feature)
            proposals.append(proposal)
        
        # 4. é‡è¤‡ãƒ»é¡ä¼¼ææ¡ˆã®çµ±åˆ
        proposals = await self._consolidate_proposals(proposals)
        
        # 5. DBã«ä¿å­˜
        for proposal in proposals:
            await self.proposal_dao.create(proposal)
        
        return proposals
    
    async def _create_quality_proposal(
        self,
        repo_id: str,
        issue: QualityIssue,
    ) -> ImprovementProposal:
        """å“è³ªå•é¡Œã‹ã‚‰æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆ"""
        
        # ã‚«ãƒ†ã‚´ãƒªã¨ãƒªã‚¹ã‚¯ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
        category_map = {
            "complexity": ImprovementCategory.REFACTORING,
            "duplication": ImprovementCategory.REFACTORING,
            "design": ImprovementCategory.REFACTORING,
            "error_handling": ImprovementCategory.BUG_FIX,
            "performance": ImprovementCategory.PERFORMANCE,
            "testability": ImprovementCategory.TEST_COVERAGE,
        }
        
        risk_map = {
            "critical": ImprovementRisk.HIGH,
            "high": ImprovementRisk.MEDIUM,
            "medium": ImprovementRisk.LOW,
            "low": ImprovementRisk.NONE,
        }
        
        return ImprovementProposal(
            id=generate_id(),
            repo_id=repo_id,
            category=category_map.get(issue.category, ImprovementCategory.CODE_QUALITY),
            priority=self._severity_to_priority(issue.severity),
            risk=risk_map.get(issue.severity, ImprovementRisk.LOW),
            status=ImprovementStatus.PROPOSED,
            title=issue.title,
            description=issue.description,
            rationale=f"é™çš„è§£æã«ã‚ˆã‚Šæ¤œå‡º: {issue.category}",
            expected_benefit=issue.suggestion or "ã‚³ãƒ¼ãƒ‰å“è³ªã®å‘ä¸Š",
            target_files=[issue.file_path],
            source_analyzer="code_analyzer",
            impact_score=self._calculate_impact(issue),
            confidence_score=0.8,  # é™çš„è§£æã¯é«˜ä¿¡é ¼åº¦
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )
```

### Task Prioritizerï¼ˆå„ªå…ˆåº¦æ±ºå®šï¼‰

```python
# apps/api/src/dursor_api/services/task_prioritizer.py

@dataclass
class PrioritizationCriteria:
    """å„ªå…ˆåº¦æ±ºå®šã®åŸºæº–"""
    security_weight: float = 1.0     # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œã®é‡ã¿
    bug_weight: float = 0.9          # ãƒã‚°ã®é‡ã¿
    performance_weight: float = 0.7  # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®é‡ã¿
    quality_weight: float = 0.5      # ã‚³ãƒ¼ãƒ‰å“è³ªã®é‡ã¿
    feature_weight: float = 0.4      # æ©Ÿèƒ½è¿½åŠ ã®é‡ã¿
    
    recency_factor: float = 0.1      # æ–°ã—ã„ã»ã©å„ªå…ˆ
    confidence_factor: float = 0.2   # ç¢ºä¿¡åº¦ã®å½±éŸ¿


class TaskPrioritizer:
    """æ”¹å–„ææ¡ˆã®å„ªå…ˆåº¦ã‚’æ±ºå®š"""
    
    def __init__(self, criteria: PrioritizationCriteria | None = None):
        self.criteria = criteria or PrioritizationCriteria()
    
    def prioritize(
        self,
        proposals: list[ImprovementProposal],
    ) -> list[ImprovementProposal]:
        """ææ¡ˆã‚’å„ªå…ˆåº¦é †ã«ã‚½ãƒ¼ãƒˆ"""
        
        scored_proposals = [
            (proposal, self._calculate_score(proposal))
            for proposal in proposals
        ]
        
        # ã‚¹ã‚³ã‚¢ã®é«˜ã„é †ã«ã‚½ãƒ¼ãƒˆ
        scored_proposals.sort(key=lambda x: x[1], reverse=True)
        
        # å„ªå…ˆåº¦ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
        for i, (proposal, score) in enumerate(scored_proposals):
            if score >= 0.8:
                proposal.priority = ImprovementPriority.CRITICAL
            elif score >= 0.6:
                proposal.priority = ImprovementPriority.HIGH
            elif score >= 0.4:
                proposal.priority = ImprovementPriority.MEDIUM
            elif score >= 0.2:
                proposal.priority = ImprovementPriority.LOW
            else:
                proposal.priority = ImprovementPriority.BACKLOG
        
        return [p for p, _ in scored_proposals]
    
    def _calculate_score(self, proposal: ImprovementProposal) -> float:
        """ææ¡ˆã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—"""
        
        # ã‚«ãƒ†ã‚´ãƒªãƒ™ãƒ¼ã‚¹ã‚¹ã‚³ã‚¢
        category_weights = {
            ImprovementCategory.SECURITY: self.criteria.security_weight,
            ImprovementCategory.BUG_FIX: self.criteria.bug_weight,
            ImprovementCategory.PERFORMANCE: self.criteria.performance_weight,
            ImprovementCategory.CODE_QUALITY: self.criteria.quality_weight,
            ImprovementCategory.REFACTORING: self.criteria.quality_weight,
            ImprovementCategory.FEATURE: self.criteria.feature_weight,
        }
        
        base_score = category_weights.get(proposal.category, 0.5)
        
        # å½±éŸ¿åº¦ã‚’è€ƒæ…®
        score = base_score * proposal.impact_score
        
        # ç¢ºä¿¡åº¦ã‚’è€ƒæ…®
        score += proposal.confidence_score * self.criteria.confidence_factor
        
        return min(1.0, score)
```

### Risk Assessorï¼ˆãƒªã‚¹ã‚¯è©•ä¾¡ï¼‰

```python
# apps/api/src/dursor_api/services/risk_assessor.py

class RiskAssessor:
    """æ”¹å–„ææ¡ˆã®ãƒªã‚¹ã‚¯ã‚’è©•ä¾¡"""
    
    async def assess(
        self,
        proposal: ImprovementProposal,
        workspace_path: str,
    ) -> ImprovementRisk:
        """ææ¡ˆã®ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã‚’è©•ä¾¡"""
        
        risk_factors = []
        
        # 1. å½±éŸ¿ç¯„å›²ã®åˆ†æ
        affected_files = await self._analyze_affected_files(
            proposal.target_files,
            workspace_path,
        )
        if len(affected_files) > 10:
            risk_factors.append(("wide_impact", 0.3))
        
        # 2. APIå¤‰æ›´ã®æ¤œå‡º
        if await self._detects_api_changes(proposal):
            risk_factors.append(("api_change", 0.4))
        
        # 3. DBå¤‰æ›´ã®æ¤œå‡º
        if await self._detects_db_changes(proposal):
            risk_factors.append(("db_change", 0.5))
        
        # 4. ä¾å­˜é–¢ä¿‚ã®å¤‰æ›´
        if proposal.category == ImprovementCategory.DEPENDENCY_UPDATE:
            update_type = proposal.source_data.get("update_type")
            if update_type == "major":
                risk_factors.append(("major_update", 0.4))
        
        # 5. ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®ç¢ºèª
        coverage = await self._get_test_coverage(proposal.target_files)
        if coverage < 50:
            risk_factors.append(("low_coverage", 0.2))
        
        # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
        total_risk = sum(factor[1] for factor in risk_factors)
        
        if total_risk >= 0.8:
            return ImprovementRisk.BREAKING
        elif total_risk >= 0.5:
            return ImprovementRisk.HIGH
        elif total_risk >= 0.3:
            return ImprovementRisk.MEDIUM
        elif total_risk > 0:
            return ImprovementRisk.LOW
        else:
            return ImprovementRisk.NONE
```

---

## å®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ 

### Self-Improvement Orchestrator

```python
# apps/api/src/dursor_api/services/self_improvement_orchestrator.py

class SelfImprovementOrchestrator:
    """è‡ªå·±æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’çµ±æ‹¬"""
    
    def __init__(
        self,
        # Analyzers
        code_analyzer: CodeAnalyzer,
        test_analyzer: TestAnalyzer,
        dependency_analyzer: DependencyAnalyzer,
        security_analyzer: SecurityAnalyzer,
        issue_analyzer: IssueAnalyzer,
        # Planners
        improvement_planner: ImprovementPlanner,
        task_prioritizer: TaskPrioritizer,
        risk_assessor: RiskAssessor,
        # Executors
        agentic_orchestrator: AgenticOrchestrator,
        # DAOs
        proposal_dao: ImprovementProposalDAO,
        cycle_dao: ImprovementCycleDAO,
        policy_dao: ImprovementPolicyDAO,
        task_dao: TaskDAO,
        repo_dao: RepoDAO,
        # Services
        notification_service: NotificationService,
    ):
        self.code_analyzer = code_analyzer
        self.test_analyzer = test_analyzer
        self.dependency_analyzer = dependency_analyzer
        self.security_analyzer = security_analyzer
        self.issue_analyzer = issue_analyzer
        self.improvement_planner = improvement_planner
        self.task_prioritizer = task_prioritizer
        self.risk_assessor = risk_assessor
        self.agentic_orchestrator = agentic_orchestrator
        self.proposal_dao = proposal_dao
        self.cycle_dao = cycle_dao
        self.policy_dao = policy_dao
        self.task_dao = task_dao
        self.repo_dao = repo_dao
        self.notification_service = notification_service
    
    async def run_improvement_cycle(self, repo_id: str) -> ImprovementCycle:
        """æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œ"""
        
        # 1. ãƒãƒªã‚·ãƒ¼ã‚’å–å¾—
        policy = await self.policy_dao.get_by_repo(repo_id)
        if not policy or not policy.enabled:
            raise ValueError(f"Self-improvement is disabled for repo {repo_id}")
        
        # 2. ã‚µã‚¤ã‚¯ãƒ«è¨˜éŒ²ã‚’ä½œæˆ
        cycle = ImprovementCycle(
            id=generate_id(),
            repo_id=repo_id,
            started_at=datetime.utcnow(),
            status="running",
        )
        await self.cycle_dao.create(cycle)
        
        try:
            # 3. åˆ†æãƒ•ã‚§ãƒ¼ã‚º
            analysis_results = await self._analyze_phase(repo_id, policy)
            cycle.analysis_summary = analysis_results.to_dict()
            
            # 4. è¨ˆç”»ãƒ•ã‚§ãƒ¼ã‚º
            proposals = await self._planning_phase(repo_id, analysis_results, policy)
            cycle.proposals_generated = len(proposals)
            
            # 5. æ‰¿èªãƒ•ã‚§ãƒ¼ã‚º
            approved_proposals = await self._approval_phase(proposals, policy)
            cycle.proposals_approved = len(approved_proposals)
            
            # 6. å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚º
            executed_count, completed_count = await self._execution_phase(
                approved_proposals, policy
            )
            cycle.proposals_executed = executed_count
            cycle.proposals_completed = completed_count
            
            # 7. å®Œäº†
            cycle.status = "completed"
            cycle.completed_at = datetime.utcnow()
            
        except Exception as e:
            cycle.status = "failed"
            cycle.analysis_summary = {"error": str(e)}
            raise
        
        finally:
            await self.cycle_dao.update(cycle)
        
        return cycle
    
    async def _analyze_phase(
        self,
        repo_id: str,
        policy: ImprovementPolicy,
    ) -> AnalysisResults:
        """åˆ†æãƒ•ã‚§ãƒ¼ã‚º"""
        
        repo = await self.repo_dao.get(repo_id)
        workspace_path = repo.workspace_path
        
        results = AnalysisResults()
        
        # æœ‰åŠ¹ãªã‚«ãƒ†ã‚´ãƒªã®ã¿åˆ†æ
        if ImprovementCategory.CODE_QUALITY in policy.enabled_categories:
            results.quality_issues = await self.code_analyzer.analyze(workspace_path)
        
        if ImprovementCategory.TEST_COVERAGE in policy.enabled_categories:
            results.test_gaps = await self.test_analyzer.analyze(workspace_path)
        
        if ImprovementCategory.DEPENDENCY_UPDATE in policy.enabled_categories:
            results.dependency_updates = await self.dependency_analyzer.analyze(workspace_path)
        
        if ImprovementCategory.SECURITY in policy.enabled_categories:
            results.security_issues = await self.security_analyzer.analyze(workspace_path)
        
        if ImprovementCategory.FEATURE in policy.enabled_categories:
            results.feature_requests = await self.issue_analyzer.analyze(repo_id)
        
        return results
    
    async def _planning_phase(
        self,
        repo_id: str,
        analysis_results: AnalysisResults,
        policy: ImprovementPolicy,
    ) -> list[ImprovementProposal]:
        """è¨ˆç”»ãƒ•ã‚§ãƒ¼ã‚º"""
        
        # 1. ææ¡ˆã‚’ç”Ÿæˆ
        proposals = await self.improvement_planner.generate_proposals(
            repo_id, analysis_results
        )
        
        # 2. ãƒªã‚¹ã‚¯è©•ä¾¡
        repo = await self.repo_dao.get(repo_id)
        for proposal in proposals:
            proposal.risk = await self.risk_assessor.assess(
                proposal, repo.workspace_path
            )
        
        # 3. å„ªå…ˆåº¦ä»˜ã‘
        proposals = self.task_prioritizer.prioritize(proposals)
        
        # 4. åˆ¶é™ã‚’é©ç”¨
        proposals = proposals[:policy.max_improvements_per_day]
        
        return proposals
    
    async def _approval_phase(
        self,
        proposals: list[ImprovementProposal],
        policy: ImprovementPolicy,
    ) -> list[ImprovementProposal]:
        """æ‰¿èªãƒ•ã‚§ãƒ¼ã‚º"""
        
        approved = []
        needs_human_approval = []
        
        for proposal in proposals:
            # è‡ªå‹•æ‰¿èªå¯èƒ½ã‹åˆ¤å®š
            if proposal.risk in policy.auto_approve_risk_levels:
                proposal.status = ImprovementStatus.APPROVED
                proposal.approved_at = datetime.utcnow()
                approved.append(proposal)
            elif proposal.risk in policy.require_human_approval_for:
                needs_human_approval.append(proposal)
            else:
                # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã§åˆ¤æ–­
                if proposal.impact_score <= policy.max_risk_score_auto:
                    proposal.status = ImprovementStatus.APPROVED
                    proposal.approved_at = datetime.utcnow()
                    approved.append(proposal)
                else:
                    needs_human_approval.append(proposal)
        
        # äººé–“æ‰¿èªãŒå¿…è¦ãªææ¡ˆã‚’é€šçŸ¥
        if needs_human_approval and policy.notify_on_proposal:
            await self._notify_proposals_for_review(needs_human_approval, policy)
        
        # DBæ›´æ–°
        for proposal in approved + needs_human_approval:
            await self.proposal_dao.update(proposal)
        
        return approved
    
    async def _execution_phase(
        self,
        proposals: list[ImprovementProposal],
        policy: ImprovementPolicy,
    ) -> tuple[int, int]:
        """å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚º"""
        
        executed = 0
        completed = 0
        
        # åŒæ™‚å®Ÿè¡Œæ•°ã‚’åˆ¶é™
        semaphore = asyncio.Semaphore(policy.max_concurrent_improvements)
        
        async def execute_proposal(proposal: ImprovementProposal):
            nonlocal executed, completed
            
            async with semaphore:
                try:
                    executed += 1
                    proposal.status = ImprovementStatus.IN_PROGRESS
                    await self.proposal_dao.update(proposal)
                    
                    # Taskã‚’ä½œæˆ
                    task = await self._create_task_from_proposal(proposal)
                    proposal.task_id = task.id
                    
                    # Full Autoãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ
                    state = await self.agentic_orchestrator.start_task(
                        task=task,
                        instruction=self._build_instruction(proposal),
                        mode=CodingMode.FULL_AUTO,
                    )
                    
                    # çµæœã‚’å¾…æ©Ÿ
                    final_state = await self._wait_for_completion(state)
                    
                    if final_state.phase == AgenticPhase.COMPLETED:
                        proposal.status = ImprovementStatus.COMPLETED
                        proposal.pr_number = final_state.pr_number
                        proposal.completed_at = datetime.utcnow()
                        completed += 1
                    else:
                        proposal.status = ImprovementStatus.FAILED
                        proposal.result_summary = final_state.error
                    
                except Exception as e:
                    proposal.status = ImprovementStatus.FAILED
                    proposal.result_summary = str(e)
                
                finally:
                    await self.proposal_dao.update(proposal)
        
        # ä¸¦åˆ—å®Ÿè¡Œ
        await asyncio.gather(*[execute_proposal(p) for p in proposals])
        
        return executed, completed
    
    def _build_instruction(self, proposal: ImprovementProposal) -> str:
        """ææ¡ˆã‹ã‚‰å®Ÿè£…æŒ‡ç¤ºã‚’ç”Ÿæˆ"""
        
        instruction = f"""
## Task: {proposal.title}

### Description
{proposal.description}

### Rationale
{proposal.rationale}

### Expected Outcome
{proposal.expected_benefit}

### Target Files
{chr(10).join(f'- {f}' for f in proposal.target_files)}

### Guidelines
- Follow existing code style and conventions
- Add/update tests as needed
- Update documentation if applicable
- Keep changes focused and minimal
"""
        return instruction
    
    async def _notify_proposals_for_review(
        self,
        proposals: list[ImprovementProposal],
        policy: ImprovementPolicy,
    ):
        """äººé–“æ‰¿èªãŒå¿…è¦ãªææ¡ˆã‚’é€šçŸ¥"""
        
        await self.notification_service.send(
            NotificationEvent(
                type=NotificationType.IMPROVEMENT_PROPOSALS,
                title=f"{len(proposals)} improvement proposals need review",
                message=self._format_proposals_summary(proposals),
                channels=policy.notification_channels,
            )
        )
```

---

## APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

```python
# apps/api/src/dursor_api/routes/self_improvement.py

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks

router = APIRouter(prefix="/v1/self-improvement", tags=["self-improvement"])


# ============================================
# Policy Management
# ============================================

@router.get("/repos/{repo_id}/policy")
async def get_policy(
    repo_id: str,
    policy_dao: ImprovementPolicyDAO = Depends(get_policy_dao),
) -> ImprovementPolicy:
    """Get self-improvement policy for a repository."""
    policy = await policy_dao.get_by_repo(repo_id)
    if not policy:
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒªã‚·ãƒ¼ã‚’è¿”ã™
        return ImprovementPolicy(
            id="default",
            repo_id=repo_id,
            enabled=False,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )
    return policy


@router.put("/repos/{repo_id}/policy")
async def update_policy(
    repo_id: str,
    data: ImprovementPolicyUpdate,
    policy_dao: ImprovementPolicyDAO = Depends(get_policy_dao),
) -> ImprovementPolicy:
    """Update self-improvement policy."""
    policy = await policy_dao.upsert(repo_id, data)
    return policy


# ============================================
# Improvement Cycles
# ============================================

@router.post("/repos/{repo_id}/cycles")
async def start_improvement_cycle(
    repo_id: str,
    background_tasks: BackgroundTasks,
    orchestrator: SelfImprovementOrchestrator = Depends(get_orchestrator),
) -> dict:
    """Start a new self-improvement cycle."""
    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œ
    cycle_id = generate_id()
    background_tasks.add_task(
        orchestrator.run_improvement_cycle,
        repo_id,
    )
    return {"cycle_id": cycle_id, "status": "started"}


@router.get("/repos/{repo_id}/cycles")
async def list_cycles(
    repo_id: str,
    limit: int = 10,
    cycle_dao: ImprovementCycleDAO = Depends(get_cycle_dao),
) -> list[ImprovementCycle]:
    """List improvement cycles for a repository."""
    return await cycle_dao.list_by_repo(repo_id, limit=limit)


@router.get("/cycles/{cycle_id}")
async def get_cycle(
    cycle_id: str,
    cycle_dao: ImprovementCycleDAO = Depends(get_cycle_dao),
) -> ImprovementCycle:
    """Get improvement cycle details."""
    cycle = await cycle_dao.get(cycle_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Cycle not found")
    return cycle


# ============================================
# Proposals
# ============================================

@router.get("/repos/{repo_id}/proposals")
async def list_proposals(
    repo_id: str,
    status: ImprovementStatus | None = None,
    category: ImprovementCategory | None = None,
    priority: ImprovementPriority | None = None,
    limit: int = 50,
    proposal_dao: ImprovementProposalDAO = Depends(get_proposal_dao),
) -> list[ImprovementProposal]:
    """List improvement proposals."""
    return await proposal_dao.list_by_repo(
        repo_id,
        status=status,
        category=category,
        priority=priority,
        limit=limit,
    )


@router.get("/proposals/{proposal_id}")
async def get_proposal(
    proposal_id: str,
    proposal_dao: ImprovementProposalDAO = Depends(get_proposal_dao),
) -> ImprovementProposal:
    """Get proposal details."""
    proposal = await proposal_dao.get(proposal_id)
    if not proposal:
        raise HTTPException(status_code=404, detail="Proposal not found")
    return proposal


@router.post("/proposals/{proposal_id}/approve")
async def approve_proposal(
    proposal_id: str,
    orchestrator: SelfImprovementOrchestrator = Depends(get_orchestrator),
) -> ImprovementProposal:
    """Manually approve a proposal."""
    return await orchestrator.approve_proposal(proposal_id)


@router.post("/proposals/{proposal_id}/reject")
async def reject_proposal(
    proposal_id: str,
    reason: str | None = None,
    proposal_dao: ImprovementProposalDAO = Depends(get_proposal_dao),
) -> ImprovementProposal:
    """Reject a proposal."""
    proposal = await proposal_dao.get(proposal_id)
    if not proposal:
        raise HTTPException(status_code=404, detail="Proposal not found")
    
    proposal.status = ImprovementStatus.REJECTED
    proposal.result_summary = reason
    await proposal_dao.update(proposal)
    return proposal


@router.post("/proposals/{proposal_id}/execute")
async def execute_proposal(
    proposal_id: str,
    background_tasks: BackgroundTasks,
    orchestrator: SelfImprovementOrchestrator = Depends(get_orchestrator),
) -> dict:
    """Manually execute an approved proposal."""
    proposal = await orchestrator.get_proposal(proposal_id)
    if proposal.status != ImprovementStatus.APPROVED:
        raise HTTPException(
            status_code=400,
            detail=f"Proposal must be approved first, current status: {proposal.status}"
        )
    
    background_tasks.add_task(
        orchestrator.execute_single_proposal,
        proposal_id,
    )
    return {"status": "execution_started"}


# ============================================
# Analysis
# ============================================

@router.post("/repos/{repo_id}/analyze")
async def trigger_analysis(
    repo_id: str,
    categories: list[ImprovementCategory] | None = None,
    orchestrator: SelfImprovementOrchestrator = Depends(get_orchestrator),
) -> dict:
    """Trigger analysis without creating proposals."""
    results = await orchestrator.analyze_only(repo_id, categories)
    return {
        "quality_issues": len(results.quality_issues),
        "test_gaps": len(results.test_gaps),
        "dependency_updates": len(results.dependency_updates),
        "security_issues": len(results.security_issues),
        "feature_requests": len(results.feature_requests),
        "details": results.to_dict(),
    }


# ============================================
# Metrics
# ============================================

@router.get("/repos/{repo_id}/metrics")
async def get_metrics(
    repo_id: str,
    orchestrator: SelfImprovementOrchestrator = Depends(get_orchestrator),
) -> dict:
    """Get self-improvement metrics for a repository."""
    return await orchestrator.get_metrics(repo_id)
```

---

## ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼

```python
# apps/api/src/dursor_api/scheduler/improvement_scheduler.py

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger


class ImprovementScheduler:
    """æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼"""
    
    def __init__(
        self,
        orchestrator: SelfImprovementOrchestrator,
        policy_dao: ImprovementPolicyDAO,
        repo_dao: RepoDAO,
    ):
        self.orchestrator = orchestrator
        self.policy_dao = policy_dao
        self.repo_dao = repo_dao
        self.scheduler = AsyncIOScheduler()
        self._jobs: dict[str, str] = {}  # repo_id -> job_id
    
    async def start(self):
        """ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã‚’é–‹å§‹"""
        # æ—¢å­˜ã®ãƒãƒªã‚·ãƒ¼ã‹ã‚‰ã‚¸ãƒ§ãƒ–ã‚’ç™»éŒ²
        policies = await self.policy_dao.list_all()
        for policy in policies:
            if policy.enabled and policy.schedule_cron:
                await self.schedule_repo(policy.repo_id, policy.schedule_cron)
        
        self.scheduler.start()
    
    async def schedule_repo(self, repo_id: str, cron_expression: str):
        """ãƒªãƒã‚¸ãƒˆãƒªã®æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«"""
        
        # æ—¢å­˜ã®ã‚¸ãƒ§ãƒ–ãŒã‚ã‚Œã°å‰Šé™¤
        if repo_id in self._jobs:
            self.scheduler.remove_job(self._jobs[repo_id])
        
        # æ–°ã—ã„ã‚¸ãƒ§ãƒ–ã‚’ç™»éŒ²
        job = self.scheduler.add_job(
            self._run_cycle,
            CronTrigger.from_crontab(cron_expression),
            args=[repo_id],
            id=f"improvement-{repo_id}",
            replace_existing=True,
        )
        
        self._jobs[repo_id] = job.id
    
    async def unschedule_repo(self, repo_id: str):
        """ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è§£é™¤"""
        if repo_id in self._jobs:
            self.scheduler.remove_job(self._jobs[repo_id])
            del self._jobs[repo_id]
    
    async def _run_cycle(self, repo_id: str):
        """æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œ"""
        try:
            logger.info(f"Starting scheduled improvement cycle for repo {repo_id}")
            await self.orchestrator.run_improvement_cycle(repo_id)
            logger.info(f"Completed improvement cycle for repo {repo_id}")
        except Exception as e:
            logger.error(f"Improvement cycle failed for repo {repo_id}: {e}")
```

---

## UIè¨­è¨ˆ

### æ”¹å–„ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```
apps/web/src/app/self-improvement/
â”œâ”€â”€ page.tsx              # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
â”œâ”€â”€ [repoId]/
â”‚   â”œâ”€â”€ page.tsx          # ãƒªãƒã‚¸ãƒˆãƒªåˆ¥è©³ç´°
â”‚   â”œâ”€â”€ proposals/        # ææ¡ˆä¸€è¦§
â”‚   â”œâ”€â”€ cycles/           # ã‚µã‚¤ã‚¯ãƒ«å±¥æ­´
â”‚   â””â”€â”€ settings/         # ãƒãƒªã‚·ãƒ¼è¨­å®š
â””â”€â”€ components/
    â”œâ”€â”€ ImprovementDashboard.tsx
    â”œâ”€â”€ ProposalCard.tsx
    â”œâ”€â”€ ProposalList.tsx
    â”œâ”€â”€ CycleTimeline.tsx
    â”œâ”€â”€ MetricsChart.tsx
    â””â”€â”€ PolicyForm.tsx
```

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹é€ 

```mermaid
graph TB
    subgraph "Self-Improvement Dashboard"
        D[Dashboard Page]
        
        subgraph "Overview Section"
            M[Metrics Summary]
            A[Active Cycles]
            R[Recent Proposals]
        end
        
        subgraph "Proposals Section"
            PL[Proposal List]
            PC[Proposal Card]
            PD[Proposal Detail Modal]
        end
        
        subgraph "Settings Section"
            PS[Policy Settings]
            SC[Schedule Config]
            NC[Notification Config]
        end
    end
    
    D --> M
    D --> A
    D --> R
    D --> PL
    PL --> PC
    PC --> PD
    D --> PS
    PS --> SC
    PS --> NC
```

### ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰UI

```tsx
// apps/web/src/app/self-improvement/page.tsx

export default function SelfImprovementDashboard() {
  const { data: repos } = useSWR('repos', reposApi.list);
  const [selectedRepo, setSelectedRepo] = useState<string | null>(null);
  
  return (
    <div className="min-h-screen bg-gray-950 text-white">
      <header className="border-b border-gray-800 p-4">
        <h1 className="text-2xl font-bold flex items-center gap-2">
          <SparklesIcon className="w-6 h-6 text-purple-400" />
          Self-Improvement
        </h1>
        <p className="text-gray-400 mt-1">
          AIãŒè‡ªå‹•çš„ã«ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’åˆ†æã—ã€æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆãƒ»å®Ÿè¡Œã—ã¾ã™
        </p>
      </header>
      
      <main className="p-6 space-y-8">
        {/* Repository Selector */}
        <RepoSelector
          repos={repos || []}
          selected={selectedRepo}
          onSelect={setSelectedRepo}
        />
        
        {selectedRepo && (
          <>
            {/* Metrics Overview */}
            <MetricsOverview repoId={selectedRepo} />
            
            {/* Active Improvements */}
            <ActiveImprovements repoId={selectedRepo} />
            
            {/* Pending Proposals */}
            <PendingProposals repoId={selectedRepo} />
            
            {/* Recent Cycles */}
            <RecentCycles repoId={selectedRepo} />
          </>
        )}
      </main>
    </div>
  );
}
```

### ææ¡ˆã‚«ãƒ¼ãƒ‰

```tsx
// apps/web/src/app/self-improvement/components/ProposalCard.tsx

interface ProposalCardProps {
  proposal: ImprovementProposal;
  onApprove: () => void;
  onReject: () => void;
  onExecute: () => void;
}

export function ProposalCard({
  proposal,
  onApprove,
  onReject,
  onExecute,
}: ProposalCardProps) {
  const priorityColors = {
    critical: 'bg-red-500',
    high: 'bg-orange-500',
    medium: 'bg-yellow-500',
    low: 'bg-blue-500',
    backlog: 'bg-gray-500',
  };
  
  const riskColors = {
    none: 'text-green-400',
    low: 'text-blue-400',
    medium: 'text-yellow-400',
    high: 'text-orange-400',
    breaking: 'text-red-400',
  };
  
  return (
    <div className="bg-gray-800 rounded-lg p-4 border border-gray-700">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div className="flex items-center gap-2">
          <span className={`px-2 py-0.5 text-xs rounded ${priorityColors[proposal.priority]}`}>
            {proposal.priority.toUpperCase()}
          </span>
          <span className="text-xs text-gray-400">
            {proposal.category.replace('_', ' ')}
          </span>
        </div>
        <span className={`text-xs ${riskColors[proposal.risk]}`}>
          Risk: {proposal.risk}
        </span>
      </div>
      
      {/* Title & Description */}
      <h3 className="mt-2 font-medium">{proposal.title}</h3>
      <p className="mt-1 text-sm text-gray-400 line-clamp-2">
        {proposal.description}
      </p>
      
      {/* Metrics */}
      <div className="mt-3 flex gap-4 text-xs text-gray-500">
        <span>Impact: {(proposal.impact_score * 100).toFixed(0)}%</span>
        <span>Confidence: {(proposal.confidence_score * 100).toFixed(0)}%</span>
        <span>{proposal.target_files.length} files</span>
      </div>
      
      {/* Actions */}
      {proposal.status === 'proposed' && (
        <div className="mt-4 flex gap-2">
          <Button
            size="sm"
            variant="primary"
            onClick={onApprove}
          >
            Approve
          </Button>
          <Button
            size="sm"
            variant="secondary"
            onClick={onReject}
          >
            Reject
          </Button>
        </div>
      )}
      
      {proposal.status === 'approved' && (
        <div className="mt-4">
          <Button
            size="sm"
            variant="primary"
            onClick={onExecute}
          >
            Execute Now
          </Button>
        </div>
      )}
      
      {proposal.status === 'in_progress' && (
        <div className="mt-4 flex items-center gap-2 text-yellow-400">
          <SpinnerIcon className="w-4 h-4 animate-spin" />
          <span className="text-sm">Executing...</span>
        </div>
      )}
      
      {proposal.status === 'completed' && proposal.pr_number && (
        <div className="mt-4">
          <a
            href={`https://github.com/.../pull/${proposal.pr_number}`}
            className="text-sm text-blue-400 hover:underline"
            target="_blank"
            rel="noopener noreferrer"
          >
            View PR #{proposal.pr_number}
          </a>
        </div>
      )}
    </div>
  );
}
```

---

## è¨­å®š

### ç’°å¢ƒå¤‰æ•°

```bash
# Self-Improvement Settings
DURSOR_SELF_IMPROVEMENT_ENABLED=true

# Default Schedule (cron)
DURSOR_IMPROVEMENT_DEFAULT_SCHEDULE="0 2 * * 1"  # æ¯é€±æœˆæ›œ2:00

# Limits
DURSOR_IMPROVEMENT_MAX_CONCURRENT=3
DURSOR_IMPROVEMENT_MAX_PER_DAY=10

# Auto-approval
DURSOR_IMPROVEMENT_AUTO_APPROVE_RISK="none,low"
DURSOR_IMPROVEMENT_REQUIRE_APPROVAL_RISK="high,breaking"
DURSOR_IMPROVEMENT_AUTO_APPROVE_MAX_SCORE=0.5

# Analysis
DURSOR_IMPROVEMENT_ENABLED_CATEGORIES="code_quality,test_coverage,dependency_update,security"

# Notifications
DURSOR_IMPROVEMENT_SLACK_WEBHOOK_URL=https://hooks.slack.com/...
```

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š (.dursor.yml)

```yaml
self_improvement:
  enabled: true
  
  schedule:
    cron: "0 2 * * 1"  # æ¯é€±æœˆæ›œ2:00
    timezone: "Asia/Tokyo"
  
  analysis:
    enabled_categories:
      - code_quality
      - test_coverage
      - dependency_update
      - security
      - documentation
    
    # é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³
    exclude_paths:
      - "vendor/**"
      - "node_modules/**"
      - "*.generated.*"
  
  approval:
    # è‡ªå‹•æ‰¿èªã™ã‚‹ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«
    auto_approve_risk:
      - none
      - low
    
    # äººé–“æ‰¿èªãŒå¿…è¦ãªãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«
    require_human_approval:
      - high
      - breaking
    
    # è‡ªå‹•æ‰¿èªã®æœ€å¤§å½±éŸ¿ã‚¹ã‚³ã‚¢
    max_auto_approve_impact: 0.5
  
  execution:
    max_concurrent: 3
    max_per_day: 10
    timeout_minutes: 60
  
  notifications:
    on_proposal: true
    on_completion: true
    on_failure: true
    channels:
      - slack
      - email
```

---

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### ãƒªã‚¹ã‚¯è»½æ¸›ç­–

| ãƒªã‚¹ã‚¯ | å¯¾ç­– |
|--------|------|
| æ„å›³ã—ãªã„ã‚³ãƒ¼ãƒ‰å¤‰æ›´ | ãƒªã‚¹ã‚¯è©•ä¾¡ + äººé–“æ‰¿èªã‚²ãƒ¼ãƒˆ |
| ç„¡é™ãƒ«ãƒ¼ãƒ— | 1æ—¥ã‚ãŸã‚Šã®å®Ÿè¡Œä¸Šé™ |
| æ©Ÿå¯†æƒ…å ±æ¼æ´© | Forbidden Patterns + Security Analyzer |
| ç ´å£Šçš„å¤‰æ›´ã®è‡ªå‹•é©ç”¨ | breaking ãƒªã‚¹ã‚¯ã¯å¸¸ã«äººé–“æ‰¿èª |
| ãƒªã‚½ãƒ¼ã‚¹éå‰°æ¶ˆè²» | åŒæ™‚å®Ÿè¡Œæ•°åˆ¶é™ + ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ |

### ç¦æ­¢ãƒ‘ã‚¿ãƒ¼ãƒ³

```python
# Self-improvementã§å¤‰æ›´ç¦æ­¢ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
FORBIDDEN_IMPROVEMENT_PATTERNS = [
    # èªè¨¼ãƒ»èªå¯é–¢é€£
    r"auth[_-]?service\.py",
    r"permission[s]?\.py",
    r"security[_-]?config",
    
    # æ©Ÿå¯†æƒ…å ±é–¢é€£
    r"\.env",
    r"credentials",
    r"secrets?\.ya?ml",
    
    # DBé–¢é€£ï¼ˆã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã¯å±é™ºï¼‰
    r"schema\.sql",
    r"migrations?/",
    
    # CI/CDè¨­å®š
    r"\.github/workflows/",
    r"Dockerfile",
    r"docker-compose",
]
```

### ç›£æŸ»ãƒ­ã‚°

```sql
-- æ”¹å–„æ´»å‹•ã®ç›£æŸ»ãƒ­ã‚°
CREATE TABLE IF NOT EXISTS improvement_audit_log (
    id TEXT PRIMARY KEY,
    timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    repo_id TEXT NOT NULL,
    proposal_id TEXT,
    action TEXT NOT NULL,  -- "analyze", "propose", "approve", "reject", "execute", "complete", "fail"
    actor TEXT NOT NULL,   -- "system", "human:{user_id}"
    details TEXT,          -- JSON
    
    FOREIGN KEY (repo_id) REFERENCES repos(id) ON DELETE CASCADE
);

CREATE INDEX idx_audit_repo ON improvement_audit_log(repo_id);
CREATE INDEX idx_audit_timestamp ON improvement_audit_log(timestamp);
```

---

## å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Phase 1: åŸºç›¤æ§‹ç¯‰ (Week 1-2)

- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ãƒ»DBã‚¹ã‚­ãƒ¼ãƒè¿½åŠ 
- [ ] DAOå®Ÿè£…ï¼ˆImprovementProposalDAO, ImprovementCycleDAO, ImprovementPolicyDAOï¼‰
- [ ] åŸºæœ¬çš„ãªAnalyzerå®Ÿè£…ï¼ˆCodeAnalyzer, DependencyAnalyzerï¼‰
- [ ] ImprovementPlanneråŸºæœ¬å®Ÿè£…

### Phase 2: è¨ˆç”»ãƒ»æ‰¿èªã‚·ã‚¹ãƒ†ãƒ  (Week 3)

- [ ] TaskPrioritizerå®Ÿè£…
- [ ] RiskAssessorå®Ÿè£…
- [ ] æ‰¿èªãƒ•ãƒ­ãƒ¼å®Ÿè£…ï¼ˆè‡ªå‹•æ‰¿èª + äººé–“æ‰¿èªï¼‰
- [ ] APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…

### Phase 3: å®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ  (Week 4)

- [ ] SelfImprovementOrchestratorå®Ÿè£…
- [ ] AgenticOrchestratorã¨ã®çµ±åˆ
- [ ] ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼å®Ÿè£…
- [ ] é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ é€£æº

### Phase 4: UIãƒ»UX (Week 5)

- [ ] ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰UI
- [ ] ææ¡ˆç®¡ç†UI
- [ ] ãƒãƒªã‚·ãƒ¼è¨­å®šUI
- [ ] ãƒ¡ãƒˆãƒªã‚¯ã‚¹å¯è¦–åŒ–

### Phase 5: é«˜åº¦ãªæ©Ÿèƒ½ (Week 6+)

- [ ] è¿½åŠ Analyzerï¼ˆTestAnalyzer, PerformanceAnalyzer, IssueAnalyzerï¼‰
- [ ] å­¦ç¿’æ©Ÿèƒ½ï¼ˆæ”¹å–„åŠ¹æœã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
- [ ] ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒ»å¯è¦–åŒ–
- [ ] A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½

---

## æˆåŠŸæŒ‡æ¨™

| æŒ‡æ¨™ | èª¬æ˜ | ç›®æ¨™ |
|------|------|------|
| **è‡ªå‹•æ”¹å–„æˆåŠŸç‡** | è‡ªå‹•å®Ÿè¡Œã•ã‚ŒãŸæ”¹å–„ã®æˆåŠŸç‡ | > 80% |
| **ææ¡ˆæ¡ç”¨ç‡** | ç”Ÿæˆã•ã‚ŒãŸææ¡ˆã®ã†ã¡å®Ÿè¡Œã•ã‚ŒãŸå‰²åˆ | > 50% |
| **å¹³å‡ä¿®æ­£æ™‚é–“** | å•é¡Œç™ºè¦‹ã‹ã‚‰ä¿®æ­£å®Œäº†ã¾ã§ã®æ™‚é–“ | < 24æ™‚é–“ |
| **ã‚³ãƒ¼ãƒ‰å“è³ªã‚¹ã‚³ã‚¢æ”¹å–„** | æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«å‰å¾Œã®å“è³ªã‚¹ã‚³ã‚¢å¤‰åŒ– | +10% / æœˆ |
| **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸æ”¹å–„** | æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«å‰å¾Œã®ã‚«ãƒãƒ¬ãƒƒã‚¸å¤‰åŒ– | +5% / æœˆ |
| **è„†å¼±æ€§è§£æ¶ˆæ™‚é–“** | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®å¹³å‡è§£æ¶ˆæ™‚é–“ | < 48æ™‚é–“ |

---

## FAQ

### Q: Self-improvementã¯ã„ã¤å®Ÿè¡Œã•ã‚Œã¾ã™ã‹ï¼Ÿ

A: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯æ¯é€±æœˆæ›œ2:00ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãƒãƒªã‚·ãƒ¼è¨­å®šã§cronå¼ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚ã¾ãŸã€æ‰‹å‹•ã§å³æ™‚å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚

### Q: äººé–“ã®æ‰¿èªãªã—ã«è‡ªå‹•ã§ã‚³ãƒ¼ãƒ‰ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã‹ï¼Ÿ

A: ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ãŒã€Œnoneã€ã¾ãŸã¯ã€Œlowã€ã®æ”¹å–„ã®ã¿è‡ªå‹•æ‰¿èªã•ã‚Œã¾ã™ã€‚ã€Œhighã€ã‚„ã€Œbreakingã€ãƒªã‚¹ã‚¯ã®æ”¹å–„ã¯å¿…ãšäººé–“ã®æ‰¿èªãŒå¿…è¦ã§ã™ã€‚ãƒãƒªã‚·ãƒ¼è¨­å®šã§å¤‰æ›´å¯èƒ½ã§ã™ã€‚

### Q: ã©ã®ã‚ˆã†ãªæ”¹å–„ãŒææ¡ˆã•ã‚Œã¾ã™ã‹ï¼Ÿ

A: ã‚³ãƒ¼ãƒ‰å“è³ªå‘ä¸Šã€ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸æ”¹å–„ã€ä¾å­˜é–¢ä¿‚æ›´æ–°ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿®æ­£ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ”¹å–„ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãªã©ãŒææ¡ˆã•ã‚Œã¾ã™ã€‚æœ‰åŠ¹ãªã‚«ãƒ†ã‚´ãƒªã¯ãƒãƒªã‚·ãƒ¼ã§è¨­å®šã§ãã¾ã™ã€‚

### Q: æ”¹å–„ãŒå¤±æ•—ã—ãŸå ´åˆã¯ã©ã†ãªã‚Šã¾ã™ã‹ï¼Ÿ

A: æ”¹å–„ã¯é€šå¸¸ã®Full Autoãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€CIå¤±æ•—æ™‚ã¯è‡ªå‹•ä¿®æ­£ãŒè©¦ã¿ã‚‰ã‚Œã¾ã™ã€‚æœ€çµ‚çš„ã«å¤±æ•—ã—ãŸå ´åˆã¯é€šçŸ¥ã•ã‚Œã€ææ¡ˆã¯ã€Œfailedã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«ãªã‚Šã¾ã™ã€‚

### Q: ç‰¹å®šã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ”¹å–„å¯¾è±¡ã‹ã‚‰é™¤å¤–ã§ãã¾ã™ã‹ï¼Ÿ

A: ã¯ã„ã€‚`.dursor.yml`ã®`exclude_paths`ã§é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®šã§ãã¾ã™ã€‚ã¾ãŸã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šé‡è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•çš„ã«é™¤å¤–ã•ã‚Œã¾ã™ã€‚

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [Agentic Dursor](./agentic-dursor.md) - Full Autoãƒ¢ãƒ¼ãƒ‰ã®è©³ç´°
- [Coding Mode](./coding-mode.md) - ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã®å®šç¾©
- [Code Review](./review.md) - AIãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
- [Architecture](./architecture.md) - ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
