# スケーラビリティ課題と優先度付き対策

対象: docs/architecture.md に記載の現行アーキテクチャ（Next.js + FastAPI、SQLite 永続化、SQLite バックド JobQueue、エグゼキューターのCLI実行、CIポーリング等）

## 概要
- 主要なボトルネックは「単一ノード・単一ライタ前提の SQLite」「SQLite バックドのポーリング型ジョブキュー」「CI ステータスのポーリング」「Run ごとの完全クローン」「CLI サブプロセス多用」に集約される。
- まずはキューとDBを分散対応へ置換し、イベント駆動化・観測可能性を整備することで、最小変更で高い効果を得られる。

## 現状の主な問題点
- データベース: SQLite は同時書き込みとロックに弱く、スループットと待ち時間が高並列で顕著に悪化。HA/フェイルオーバも困難。
- ジョブキュー: SQLite + ポーリング + `asyncio.Semaphore` はプロセス/ノードを跨ぐ協調ができず、取りこぼし/重複/スループット限界/無駄ポーリングの懸念。
- CI 取得: 30 秒間隔のポーリングは、規模増大でAPI呼び出しが線形増加し、レート制限/待ち時間の悪化を招く。
- 実行器: CLI サブプロセス生成のオーバーヘッドと資源隔離不足（CPU/メモリ/IO）。大量並列時に競合が発生。
- ワークスペース: Run ごとの `git clone --depth=1` はネットワーク帯域・ストレージIO・容量消費が大きい。差分再利用がない。
- 外部API: LLM/GitHub などのレート制限・同時実行上限・リトライ/バックオフ・コスト管理の設計が不十分。
- 観測可能性: キュー滞留/実行時間/失敗率などのKPI計測・可視化（メトリクス/トレース/構造化ログ）が不足。
- リアルタイム配信: `StreamingLogs` はあるが SSE/WS の方式・スケールパスと中継の設計が不明確。
- 冪等性と重複制御: `create_runs` 等への冪等キーや重複排除が未整備で負荷増幅の温床になり得る。
- マルチユーザー/多テナント: クォータ・スロット配賦・優先度制御の方針が未提示。

## 優先度付きロードマップ

### P0（信頼性・足回りの改善）
- キューを分散対応へ移行: 抽象キューIFを導入し、Redis ベースの実装（可視性タイムアウト、再配信、優先度、遅延、レート制限、メトリクス）を採用。SQLiteキューは開発用フォールバックに限定。
- DB を PostgreSQL へ移行: コネクションプール、適切なインデックス、`FOR UPDATE SKIP LOCKED` 相当のロック戦略、Alembic マイグレーション。まずは Job/Run/Message/PR/CICheck から段階移行。
- CI をWebhook駆動へ: GitHub/Git プロバイダのWebhookでイベント駆動更新。ポーリングは障害時フォールバック＋指数バックオフ。
- API と Worker を分離: API はステートレス化、Worker はキューのみ監視。水平スケール（N×API、M×Worker）を前提にデプロイ単位を分離。
- 観測可能性の整備: Prometheus 互換メトリクス（キュー滞留、取り出しレイテンシ、実行時間ヒストグラム、失敗率、外部APIレート/エラー）、構造化ログ、OpenTelemetry トレース。
- 冪等性の導入: `task_id` + 入力ハッシュ等の冪等キーで二重投入を防止。

### P1（効率・隔離の強化）
- ワークスペース最適化: 中央ベアミラー＋`git alternates`、`partial clone`、`sparse-checkout` を標準化。クローン時間と容量を大幅削減。
- 実行環境のコンテナ隔離: エグゼキューターを軽量コンテナで実行し、cgroup によるCPU/メモリ/IO制御とスロット管理を導入。スケジューラ（K8s/ECS 相当）でノード間分散。
- 外部APIのレート/コスト制御: プロバイダ別同時実行上限、トークンバケット、指数バックオフ＋ジッタ、LLM出力キャッシュ（プロンプト正規化＋TTL）。
- リアルタイム配信の方式確定: SSE か WebSocket に統一し、Redis Pub/Sub や NATS を中継に用いて水平スケール。
- バックプレッシャ/サーキットブレーカ: 下流障害時に投入を抑制し、回復を待つ制御を全レイヤに適用。

### P2（高可用・多テナント最適化）
- DB の高可用化とスキーマ最適化: リードレプリカ、重いクエリの再設計、ログ/成果物は別ストレージへ分離（オブジェクトストレージ＋検索系）。
- 多テナント/クォータ: ユーザー/組織/リポジトリ単位の同時実行上限、優先度、課金/予算連動。
- データライフサイクル: Run ログ/成果物のTTL・圧縮・アーカイブ移行。
- マルチリージョン/DR: 冗長キューとメタの複製、RPO/RTO の明確化と演習。

## すぐに着手できる実装タスク例
- 抽象キューIF追加＋Redis実装（`sqlite://`/`redis://` 切替可能）。
- Alembic 初期化と最初のマイグレーション作成、`docker-compose.yml` に `postgres`/`redis` を追加。
- Webhook エンドポイントを追加し `CIPollingService` をイベント駆動へ変更（ポーリングはフォールバック）。
- `RunService.create_runs()` に冪等キーを導入、重複投入は `409` で拒否。
- LLM 呼び出しのセマフォをプロバイダ別に分離し、同時実行上限・待ち行列を可視化。
- メトリクス `/metrics` を公開し、キュー滞留・処理時間・外部API失敗率を収集。
- `git` の高速化（ベアミラー＋`--reference`/alternates、`sparse-checkout` を既定化）。

## 計測目標（例）
- キュー滞留 p95 < 5s、ジョブ開始まで p95 < 10s。
- 外部APIレート制限エラー < 1%、5xx 率 < 0.1%。
- `git clone` 平均時間 50%以上削減、Run あたりディスク使用量 60%以上削減。
- 単一リージョンで安定同時実行数を現状比 4× まで引き上げ。

